# Fijamos una semilla para que el modelo sea reproducible.
set.seed(123)
# 4. Entrenamiento del Modelo
# Entrenamos el Modelo 3, prediciendo 'Price_Change' con todas nuestras variables.
rf_modelo_final <- randomForest(
Price_Change ~ Earnings_Change + Dividend_Change + Interest_Rate_Change + Price_Change_Lag1 + SMA_10_Price_Change,
data = train_set,
ntree = 500,
# 'nodesize' y 'mtry' son ajustes para que el modelo sea más general y estable.
nodesize = 10,
mtry = 3
)
# 5. Predicción y Reconstrucción
# 1. Predecimos los *cambios* de precio en el set de prueba.
predicted_changes <- predict(rf_modelo_final, newdata = test_set)
# 2. Creamos un vector vacío para guardar nuestros precios reconstruidos.
reconstructed_predictions <- numeric(length(predicted_changes))
# INICIO DEL BUCLE
# Este bucle calcula la predicción de cada mes basándose en el precio REAL del mes anterior.
for (i in 1:length(predicted_changes)) {
# 3. Identificamos el precio "base" REAL sobre el que calcular el cambio.
if (i == 1) {
# Para la primera predicción, el precio base es el último real del set de entrenamiento.
base_price <- train_set$Real.Price[nrow(train_set)]
} else {
# Para todas las demás, el precio base es el valor REAL del mes anterior (del set de prueba).
base_price <- test_set$Real.Price[i - 1]
}
# 4. Calculamos el precio predicho (Precio_Base_Real * (1 + Cambio_Predicho)).
predicted_price <- base_price * (1 + predicted_changes[i])
# 5. Guardamos la predicción en nuestro vector.
reconstructed_predictions[i] <- predicted_price
}
# 6. Resultados y Gráfico
# Creamos un dataframe final para comparar lo Real vs. la Predicción.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = reconstructed_predictions
)
# Dibujamos el gráfico (que ahora debería ajustarse mucho mejor).
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue', ylim=range(c(resultados$Real, resultados$Prediccion)),
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 3: Predicción Corregida")
# Añadimos la línea de predicción.
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
# Añadimos la leyenda.
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# 1. Calculamos la matriz de importancia de las variables
importancia_modelo <- importance(rf_modelo_final)
print("Matriz de Importancia de Variables (%IncMSE):")
print(importancia_modelo)
varImpPlot(rf_modelo_final, main = "Importancia de Variables")
residuos <- resultados$Real - resultados$Prediccion
plot(resultados$Fecha, residuos,
type = 'h', # 'h' dibuja líneas verticales desde y=0, ideal para residuos
col = "blue",
main = "Diagnóstico: Residuos del Modelo 3 (vs. Tiempo)",
xlab = "Fecha",
ylab = "Error de Predicción (Residuos)")
abline(h = 0, col = "red", lty = 2)
# 1. Creamos un dataframe comparando el cambio REAL con el cambio PREDICHO
comparacion_df <- data.frame(
Cambio_Real = test_set$Price_Change,
Cambio_Predicho = predicted_changes
)
# 2. Determinamos la dirección (1 para subida, -1 para bajada, 0 para plano)
comparacion_df$Direccion_Real <- sign(comparacion_df$Cambio_Real)
comparacion_df$Direccion_Predicha <- sign(comparacion_df$Cambio_Predicho)
# 3. Comparamos si las direcciones coinciden
# (Ignoramos los casos 'planos' (0) ya que son raros y ambiguos)
comparacion_df <- comparacion_df[comparacion_df$Direccion_Real != 0 & comparacion_df$Direccion_Predicha != 0, ]
comparacion_df$Acierto <- (comparacion_df$Direccion_Real == comparacion_df$Direccion_Predicha)
# 4. Calculamos el "Porcentaje de Éxito" (la media de aciertos)
precision_direccional <- mean(comparacion_df$Acierto, na.rm = TRUE)
# 5. Mostramos el resultado
print(paste0("Porcentaje de Éxito: ",
round(precision_direccional * 100, 3),
"%"))
# Cargamos los paquetes necesarios para manipular datos (dplyr), crear el modelo (randomForest) y calcular la media móvil (TTR).
library(dplyr)
library(randomForest)
library(TTR)
# 1. Carga y Preparación de Datos
# Cargamos los datos del CSV.
datos <- read.csv("actividad2/SP.csv")
# Ordenamos los datos por fecha, de más antiguo a más reciente.
datos <- datos[order(as.Date(datos$Date)), ]
# 2. Ingeniería de Variables (Feature Engineering)
# Transformamos los datos para predecir el 'cambio' en lugar del 'precio'.
datos <- datos %>%
mutate(
# Variable objetivo: cambio porcentual del precio.
Price_Change = (Real.Price / lag(Real.Price)) - 1,
# Predictor: cambio porcentual de las ganancias.
Earnings_Change = (Real.Earnings / lag(Real.Earnings)) - 1,
# Predictor: cambio porcentual de los dividendos.
Dividend_Change = (Real.Dividend / lag(Real.Dividend)) - 1,
# Predictor: cambio absoluto de la tasa de interés.
Interest_Rate_Change = Long.Interest.Rate - lag(Long.Interest.Rate),
# Variables de Contexto (La Novedad del Modelo 3)
# Predictor de 'Memoria': el cambio de precio del mes anterior.
Price_Change_Lag1 = lag(Price_Change, 1),
# Predictor de 'Tendencia': la media móvil de los últimos 10 cambios de precio.
SMA_10_Price_Change = SMA(Price_Change, n = 10)
)
# Eliminamos las filas con NAs creadas por las funciones 'lag' y 'SMA'.
datos <- na.omit(datos)
# 3. División de Datos (Train/Test)
# Definimos el punto de corte (80% para entrenar, 20% para probar).
punto_corte <- floor(0.8 * nrow(datos))
# Creamos el set de entrenamiento (el pasado).
train_set <- datos[1:punto_corte, ]
# Creamos el set de prueba (el futuro).
test_set <- datos[(punto_corte + 1):nrow(datos), ]
# Fijamos una semilla para que el modelo sea reproducible.
set.seed(123)
# 4. Entrenamiento del Modelo
# Entrenamos el Modelo 3, prediciendo 'Price_Change' con todas nuestras variables.
rf_modelo_final <- randomForest(
Price_Change ~ Earnings_Change + Dividend_Change + Interest_Rate_Change + Price_Change_Lag1 + SMA_10_Price_Change,
data = train_set,
ntree = 500,
# 'nodesize' y 'mtry' son ajustes para que el modelo sea más general y estable.
nodesize = 10,
mtry = 3
)
# 5. Predicción y Reconstrucción
# 1. Predecimos los *cambios* de precio en el set de prueba.
predicted_changes <- predict(rf_modelo_final, newdata = test_set)
# 2. Creamos un vector vacío para guardar nuestros precios reconstruidos.
reconstructed_predictions <- numeric(length(predicted_changes))
# INICIO DEL BUCLE
# Este bucle calcula la predicción de cada mes basándose en el precio REAL del mes anterior.
for (i in 1:length(predicted_changes)) {
# 3. Identificamos el precio "base" REAL sobre el que calcular el cambio.
if (i == 1) {
# Para la primera predicción, el precio base es el último real del set de entrenamiento.
base_price <- train_set$Real.Price[nrow(train_set)]
} else {
# Para todas las demás, el precio base es el valor REAL del mes anterior (del set de prueba).
base_price <- test_set$Real.Price[i - 1]
}
# 4. Calculamos el precio predicho (Precio_Base_Real * (1 + Cambio_Predicho)).
predicted_price <- base_price * (1 + predicted_changes[i])
# 5. Guardamos la predicción en nuestro vector.
reconstructed_predictions[i] <- predicted_price
}
# 6. Resultados y Gráfico
# Creamos un dataframe final para comparar lo Real vs. la Predicción.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = reconstructed_predictions
)
# Dibujamos el gráfico (que ahora debería ajustarse mucho mejor).
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue', ylim=range(c(resultados$Real, resultados$Prediccion)),
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 3: Predicción Corregida")
# Añadimos la línea de predicción.
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
# Añadimos la leyenda.
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# 1. Calculamos la matriz de importancia de las variables
importancia_modelo <- importance(rf_modelo_final)
print("Matriz de Importancia de Variables (%IncMSE):")
print(importancia_modelo)
varImpPlot(rf_modelo_final, main = "Importancia de Variables")
residuos <- resultados$Real - resultados$Prediccion
plot(resultados$Fecha, residuos,
type = 'h', # 'h' dibuja líneas verticales desde y=0, ideal para residuos
col = "blue",
main = "Diagnóstico: Residuos del Modelo 3 (vs. Tiempo)",
xlab = "Fecha",
ylab = "Error de Predicción (Residuos)")
abline(h = 0, col = "red", lty = 2)
# 1. Creamos un dataframe comparando el cambio REAL con el cambio PREDICHO
comparacion_df <- data.frame(
Cambio_Real = test_set$Price_Change,
Cambio_Predicho = predicted_changes
)
# 2. Determinamos la dirección (1 para subida, -1 para bajada, 0 para plano)
comparacion_df$Direccion_Real <- sign(comparacion_df$Cambio_Real)
comparacion_df$Direccion_Predicha <- sign(comparacion_df$Cambio_Predicho)
# 3. Comparamos si las direcciones coinciden
# (Ignoramos los casos 'planos' (0) ya que son raros y ambiguos)
comparacion_df <- comparacion_df[comparacion_df$Direccion_Real != 0 & comparacion_df$Direccion_Predicha != 0, ]
comparacion_df$Acierto <- (comparacion_df$Direccion_Real == comparacion_df$Direccion_Predicha)
# 4. Calculamos el "Porcentaje de Éxito" (la media de aciertos)
precision_direccional <- mean(comparacion_df$Acierto, na.rm = TRUE)
# 5. Mostramos el resultado
print(paste0("Porcentaje de Éxito: ",
round(precision_direccional * 100, 3),
"%"))
# Cargamos los paquetes necesarios para manipular datos (dplyr), crear el modelo (randomForest) y calcular la media móvil (TTR).
library(dplyr)
library(randomForest)
library(TTR)
# 1. Carga y Preparación de Datos
# Cargamos los datos del CSV.
datos <- read.csv("actividad2/SP.csv")
# Ordenamos los datos por fecha, de más antiguo a más reciente.
datos <- datos[order(as.Date(datos$Date)), ]
# 2. Ingeniería de Variables (Feature Engineering)
# Transformamos los datos para predecir el 'cambio' en lugar del 'precio'.
datos <- datos %>%
mutate(
# Variable objetivo: cambio porcentual del precio.
Price_Change = (Real.Price / lag(Real.Price)) - 1,
# Predictor: cambio porcentual de las ganancias.
Earnings_Change = (Real.Earnings / lag(Real.Earnings)) - 1,
# Predictor: cambio porcentual de los dividendos.
Dividend_Change = (Real.Dividend / lag(Real.Dividend)) - 1,
# Predictor: cambio absoluto de la tasa de interés.
Interest_Rate_Change = Long.Interest.Rate - lag(Long.Interest.Rate),
# Variables de Contexto (La Novedad del Modelo 3)
# Predictor de 'Memoria': el cambio de precio del mes anterior.
Price_Change_Lag1 = lag(Price_Change, 1),
# Predictor de 'Tendencia': la media móvil de los últimos 10 cambios de precio.
SMA_10_Price_Change = SMA(Price_Change, n = 10)
)
# Eliminamos las filas con NAs creadas por las funciones 'lag' y 'SMA'.
datos <- na.omit(datos)
# 3. División de Datos (Train/Test)
# Definimos el punto de corte (80% para entrenar, 20% para probar).
punto_corte <- floor(0.8 * nrow(datos))
# Creamos el set de entrenamiento (el pasado).
train_set <- datos[1:punto_corte, ]
# Creamos el set de prueba (el futuro).
test_set <- datos[(punto_corte + 1):nrow(datos), ]
# Fijamos una semilla para que el modelo sea reproducible.
set.seed(123)
# 4. Entrenamiento del Modelo
# Entrenamos el Modelo 3, prediciendo 'Price_Change' con todas nuestras variables.
rf_modelo_final <- randomForest(
Price_Change ~ Earnings_Change + Dividend_Change + Interest_Rate_Change + Price_Change_Lag1 + SMA_10_Price_Change,
data = train_set,
ntree = 500,
# 'nodesize' y 'mtry' son ajustes para que el modelo sea más general y estable.
nodesize = 10,
mtry = 3
)
# 5. Predicción y Reconstrucción
# 1. Predecimos los *cambios* de precio en el set de prueba.
predicted_changes <- predict(rf_modelo_final, newdata = test_set)
# 2. Creamos un vector vacío para guardar nuestros precios reconstruidos.
reconstructed_predictions <- numeric(length(predicted_changes))
# INICIO DEL BUCLE
# Este bucle calcula la predicción de cada mes basándose en el precio REAL del mes anterior.
for (i in 1:length(predicted_changes)) {
# 3. Identificamos el precio "base" REAL sobre el que calcular el cambio.
if (i == 1) {
# Para la primera predicción, el precio base es el último real del set de entrenamiento.
base_price <- train_set$Real.Price[nrow(train_set)]
} else {
# Para todas las demás, el precio base es el valor REAL del mes anterior (del set de prueba).
base_price <- test_set$Real.Price[i - 1]
}
# 4. Calculamos el precio predicho (Precio_Base_Real * (1 + Cambio_Predicho)).
predicted_price <- base_price * (1 + predicted_changes[i])
# 5. Guardamos la predicción en nuestro vector.
reconstructed_predictions[i] <- predicted_price
}
# 6. Resultados y Gráfico
# Creamos un dataframe final para comparar lo Real vs. la Predicción.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = reconstructed_predictions
)
# Dibujamos el gráfico (que ahora debería ajustarse mucho mejor).
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue', ylim=range(c(resultados$Real, resultados$Prediccion)),
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 3: Predicción Corregida")
# Añadimos la línea de predicción.
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
# Añadimos la leyenda.
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# 1. Calculamos la matriz de importancia de las variables
importancia_modelo <- importance(rf_modelo_final)
print("Matriz de Importancia de Variables (%IncMSE):")
print(importancia_modelo)
varImpPlot(rf_modelo_final, main = "Importancia de Variables")
residuos <- resultados$Real - resultados$Prediccion
plot(resultados$Fecha, residuos,
type = 'h', # 'h' dibuja líneas verticales desde y=0, ideal para residuos
col = "blue",
main = "Diagnóstico: Residuos del Modelo 3 (vs. Tiempo)",
xlab = "Fecha",
ylab = "Error de Predicción (Residuos)")
abline(h = 0, col = "red", lty = 2)
# 1. Creamos un dataframe comparando el cambio REAL con el cambio PREDICHO
comparacion_df <- data.frame(
Cambio_Real = test_set$Price_Change,
Cambio_Predicho = predicted_changes
)
# 2. Determinamos la dirección (1 para subida, -1 para bajada, 0 para plano)
comparacion_df$Direccion_Real <- sign(comparacion_df$Cambio_Real)
comparacion_df$Direccion_Predicha <- sign(comparacion_df$Cambio_Predicho)
# 3. Comparamos si las direcciones coinciden
# (Ignoramos los casos 'planos' (0) ya que son raros y ambiguos)
comparacion_df <- comparacion_df[comparacion_df$Direccion_Real != 0 & comparacion_df$Direccion_Predicha != 0, ]
comparacion_df$Acierto <- (comparacion_df$Direccion_Real == comparacion_df$Direccion_Predicha)
# 4. Calculamos el "Porcentaje de Éxito" (la media de aciertos)
precision_direccional <- mean(comparacion_df$Acierto, na.rm = TRUE)
# 5. Mostramos el resultado
print(paste0("Porcentaje de Éxito: ",
round(precision_direccional * 100, 3),
"%"))
\newpage
# Cargamos el paquete 'randomForest' para poder usar este algoritmo.
library(randomForest)
# Leemos los datos desde nuestro archivo CSV.
datos <- read.csv("actividad2/SP.csv")
# Ordenamos todos los datos por fecha, del más antiguo al más reciente.
datos <- datos[order(as.Date(datos$Date)),]
# Calculamos dónde cortar los datos (el 80%) para separar entrenamiento y prueba.
punto_corte <- floor(0.8 * nrow(datos))
# Creamos el set de entrenamiento con el primer 80% de los datos (el pasado).
train_set <- datos[1:punto_corte, ]
# Creamos el set de prueba con el 20% final de los datos (el futuro).
test_set <- datos[(punto_corte + 1):nrow(datos), ]
# Fijamos una semilla (123) para que el modelo siempre dé el mismo resultado al ejecutarse.
set.seed(123)
# Entrenamos el Modelo 1 (Random Forest) para predecir el precio (`Real.Price`) usando los datos de entrenamiento.
rf_modelo <- randomForest(Real.Price ~ Real.Earnings + Real.Dividend + Long.Interest.Rate,
data = train_set,
ntree = 500,
na.action = na.omit)
# Mostramos un resumen de cómo se ha construido el modelo.
print(rf_modelo)
# Usamos el modelo entrenado para predecir los precios en el set de prueba (los datos que nunca ha visto).
predicciones <- predict(rf_modelo, newdata = test_set)
# Creamos una nueva tabla 'resultados' para comparar fácilmente los valores reales con los predichos.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = predicciones
)
# Dibujamos la línea azul, que representa el precio real del S&P 500.
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue',
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 1: Predicción vs. Valor Real")
# Añadimos la línea roja discontinua, que representa la predicción de nuestro modelo.
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
# Añadimos una leyenda al gráfico para saber qué es cada línea.
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# Calculamos qué variables (Earnings, Dividend, etc.) han sido más importantes para el modelo.
importancia <- importance(rf_modelo)
# Mostramos la puntuación de importancia de cada variable.
print(importancia)
# Cargamos 'dplyr', un paquete esencial para manipular y transformar datos fácilmente.
library(dplyr)
library(randomForest)
datos <- read.csv("actividad2/SP.csv")
datos <- datos[order(as.Date(datos$Date)),]
# Iniciamos una cadena de operaciones ('pipe') sobre el dataframe 'datos' usando dplyr.
datos <- datos %>%
mutate(
# Creamos 'Price_Change', nuestro nuevo objetivo a predecir (el cambio porcentual del precio).
Price_Change = (Real.Price / lag(Real.Price)) - 1,
# Creamos 'Earnings_Change', el cambio porcentual de las ganancias (ahora es un predictor).
Earnings_Change = (Real.Earnings / lag(Real.Earnings)) - 1,
# Creamos 'Dividend_Change', el cambio porcentual de los dividendos.
Dividend_Change = (Real.Dividend / lag(Real.Dividend)) - 1,
# Creamos 'Interest_Rate_Change', la diferencia (cambio absoluto) en la tasa de interés.
Interest_Rate_Change = Long.Interest.Rate - lag(Long.Interest.Rate)
)
# Eliminamos las primeras filas que ahora tienen 'NA' (datos faltantes) por el cálculo de 'lag'.
datos <- na.omit(datos)
# (La división de datos train/test es igual que antes)
punto_corte <- floor(0.8 * nrow(datos))
train_set <- datos[1:punto_corte, ]
test_set <- datos[(punto_corte + 1):nrow(datos), ]
set.seed(123)
# Entrenamos el Modelo 2 para predecir el *cambio* (`Price_Change`) usando los cambios de los predictores.
rf_modelo_mejorado <- randomForest(Price_Change ~ Earnings_Change + Dividend_Change + Interest_Rate_Change,
data = train_set,
ntree = 500)
# 1. Usamos el modelo 2 para predecir los cambios de precio, no el precio final.
predicted_changes <- predict(rf_modelo_mejorado, newdata = test_set)
# 2. Obtenemos el último precio real conocido (el del final del set de entrenamiento) como punto de partida.
last_known_price <- train_set$Real.Price[nrow(train_set)]
# Creamos un vector vacío para guardar los precios que vamos a reconstruir.
reconstructed_predictions <- numeric(length(predicted_changes))
# 3. Iniciamos un bucle que recorre cada predicción de cambio, una por una, para "reconstruir" el precio.
for (i in 1:length(predicted_changes)) {
# Calculamos el precio predicho de este mes (Precio_Ayer * (1 + Cambio_Predicho_Hoy)).
predicted_price <- last_known_price * (1 + predicted_changes[i])
# Guardamos el precio reconstruido en nuestro vector.
reconstructed_predictions[i] <- predicted_price
# Actualizamos el 'último precio' para que sea el punto de partida de la siguiente predicción.
last_known_price <- predicted_price
}
# 4. Creamos la tabla de resultados usando nuestras predicciones reconstruidas.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = reconstructed_predictions
)
# Dibujamos el gráfico, ajustando el eje Y (`ylim`) para que quepan tanto la línea real como la predicha.
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue', ylim=range(c(resultados$Real, resultados$Prediccion)),
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 2: Predicción de Cambios")
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# Cargamos los paquetes necesarios para manipular datos (dplyr), crear el modelo (randomForest) y calcular la media móvil (TTR).
library(dplyr)
library(randomForest)
library(TTR)
# 1. Carga y Preparación de Datos
# Cargamos los datos del CSV.
datos <- read.csv("actividad2/SP.csv")
# Ordenamos los datos por fecha, de más antiguo a más reciente.
datos <- datos[order(as.Date(datos$Date)), ]
# 2. Ingeniería de Variables (Feature Engineering)
# Transformamos los datos para predecir el 'cambio' en lugar del 'precio'.
datos <- datos %>%
mutate(
# Variable objetivo: cambio porcentual del precio.
Price_Change = (Real.Price / lag(Real.Price)) - 1,
# Predictor: cambio porcentual de las ganancias.
Earnings_Change = (Real.Earnings / lag(Real.Earnings)) - 1,
# Predictor: cambio porcentual de los dividendos.
Dividend_Change = (Real.Dividend / lag(Real.Dividend)) - 1,
# Predictor: cambio absoluto de la tasa de interés.
Interest_Rate_Change = Long.Interest.Rate - lag(Long.Interest.Rate),
# Variables de Contexto (La Novedad del Modelo 3)
# Predictor de 'Memoria': el cambio de precio del mes anterior.
Price_Change_Lag1 = lag(Price_Change, 1),
# Predictor de 'Tendencia': la media móvil de los últimos 10 cambios de precio.
SMA_10_Price_Change = SMA(Price_Change, n = 10)
)
# Eliminamos las filas con NAs creadas por las funciones 'lag' y 'SMA'.
datos <- na.omit(datos)
# 3. División de Datos (Train/Test)
# Definimos el punto de corte (80% para entrenar, 20% para probar).
punto_corte <- floor(0.8 * nrow(datos))
# Creamos el set de entrenamiento (el pasado).
train_set <- datos[1:punto_corte, ]
# Creamos el set de prueba (el futuro).
test_set <- datos[(punto_corte + 1):nrow(datos), ]
# Fijamos una semilla para que el modelo sea reproducible.
set.seed(123)
# 4. Entrenamiento del Modelo
# Entrenamos el Modelo 3, prediciendo 'Price_Change' con todas nuestras variables.
rf_modelo_final <- randomForest(
Price_Change ~ Earnings_Change + Dividend_Change + Interest_Rate_Change + Price_Change_Lag1 + SMA_10_Price_Change,
data = train_set,
ntree = 500,
# 'nodesize' y 'mtry' son ajustes para que el modelo sea más general y estable.
nodesize = 10,
mtry = 3
)
# 5. Predicción y Reconstrucción
# 1. Predecimos los cambios de precio en el set de prueba.
predicted_changes <- predict(rf_modelo_final, newdata = test_set)
# 2. Creamos un vector vacío para guardar nuestros precios reconstruidos.
reconstructed_predictions <- numeric(length(predicted_changes))
# Este bucle calcula la predicción de cada mes basándose en el precio REAL del mes anterior.
for (i in 1:length(predicted_changes)) {
# 3. Identificamos el precio "base" REAL sobre el que calcular el cambio.
if (i == 1) {
# Para la primera predicción, el precio base es el último real del set de entrenamiento.
base_price <- train_set$Real.Price[nrow(train_set)]
} else {
# Para todas las demás, el precio base es el valor REAL del mes anterior (del set de prueba).
base_price <- test_set$Real.Price[i - 1]
}
# 4. Calculamos el precio predicho (Precio_Base_Real * (1 + Cambio_Predicho)).
predicted_price <- base_price * (1 + predicted_changes[i])
# 5. Guardamos la predicción en nuestro vector.
reconstructed_predictions[i] <- predicted_price
}
# 6. Resultados y Gráfico
# Creamos un dataframe final para comparar lo Real vs. la Predicción.
resultados <- data.frame(
Fecha = as.Date(test_set$Date),
Real = test_set$Real.Price,
Prediccion = reconstructed_predictions
)
# Dibujamos el gráfico (que ahora debería ajustarse mucho mejor).
plot(resultados$Fecha, resultados$Real, type = 'l', col = 'blue', ylim=range(c(resultados$Real, resultados$Prediccion)),
xlab = "Fecha", ylab = "Precio Real", main = "Modelo 3: Predicción Corregida")
# Añadimos la línea de predicción.
lines(resultados$Fecha, resultados$Prediccion, col = 'red', lty = 2)
# Añadimos la leyenda.
legend("topleft", legend = c("Valor Real", "Predicción"), col = c("blue", "red"), lty = 1:2)
# 1. Calculamos la matriz de importancia de las variables
importancia_modelo <- importance(rf_modelo_final)
print("Matriz de Importancia de Variables (%IncMSE):")
print(importancia_modelo)
varImpPlot(rf_modelo_final, main = "Importancia de Variables")
residuos <- resultados$Real - resultados$Prediccion
plot(resultados$Fecha, residuos,
type = 'h', # 'h' dibuja líneas verticales desde y=0, ideal para residuos
col = "blue",
main = "Diagnóstico: Residuos del Modelo 3 (vs. Tiempo)",
xlab = "Fecha",
ylab = "Error de Predicción (Residuos)")
abline(h = 0, col = "red", lty = 2)
#Intento de indicador nuevo, no explicado en el informe:
comparacion_df <- data.frame(
Cambio_Real = test_set$Price_Change,
Cambio_Predicho = predicted_changes
)
comparacion_df$Direccion_Real <- sign(comparacion_df$Cambio_Real)
comparacion_df$Direccion_Predicha <- sign(comparacion_df$Cambio_Predicho)
# 3. Comparamos si las direcciones coinciden
comparacion_df <- comparacion_df[comparacion_df$Direccion_Real != 0 & comparacion_df$Direccion_Predicha != 0, ]
comparacion_df$Acierto <- (comparacion_df$Direccion_Real == comparacion_df$Direccion_Predicha)
# 4. Calculamos el "Porcentaje de Éxito" (la media de aciertos)
precision_direccional <- mean(comparacion_df$Acierto, na.rm = TRUE)
# 5. Mostramos el resultado
print(paste0("Porcentaje de Éxito: ",
round(precision_direccional * 100, 3),
"%"))
