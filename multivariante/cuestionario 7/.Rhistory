((Volatility/100)^2)/2)*TimeToMaturity
LNSD <- (Volatility/100)*sqrt(TimeToMaturity)
# ---
# Definir el rango del eje X para las gráficas
# ---
# El rango se basará en la distribución Normal de comparación
LowerBound = NormalM - 10*NormalSD
UpperBound = NormalM + 10*NormalSD
StepSize = (UpperBound - LowerBound)/(NumberOfObservations-1)
# Guarda el StockPrice original, ya que la variable se usará dentro del bucle
OriginalSP <- StockPrice
# ---
# Bucle principal para generar los puntos (x, y) de las gráficas
# ---
for(i in 1:NumberOfObservations){
# Calcula el valor del Eje X (Precio) para esta iteración
SP[i] <- as.double(LowerBound + (i-1)*StepSize)
# Sobrescribe temporalmente la variable 'StockPrice'
StockPrice <- SP[i]
# Calcula la PDF y CDF de la distribución NORMAL simple
NormalPDFV[i] <- NormalPDF(StockPrice, NormalM, NormalSD)
NormalCDFV[i] <- NormalCDF(StockPrice, NormalM, NormalSD)
# La Lognormal solo está definida para precios > 0
if(StockPrice > 0){
# Calcula la PDF y CDF Lognormal usando los parámetros BSM (subyacentes)
LognormalPDFV[i] <- LognormalPDF(StockPrice, LNMean, LNSD)
LognormalCDFV[i] <- LognormalCDF(StockPrice, LNMean, LNSD)
} else {
# Asigna NA (Not Available) si el precio es 0 o negativo
LognormalPDFV[i] <- NA
LognormalCDFV[i] <- NA
}
}
# Restaura el valor original de StockPrice
StockPrice <- OriginalSP
# ---
# 2. SECCIÓN DE GRÁFICOS
# ---
# Define los límites del eje X si la variable global 'FixXAxis' es VERDADERA
if(FixXAxis == TRUE){
MaxXValue <- 500
MinXValue <- -500
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# ---
# Gráfico 1: PDF Normal
# ---
x <- SP
y1 <- NormalPDFV
# Fija los límites del eje Y para la PDF si 'FixYPDFAxis' es VERDADERO
if(FixYPDFAxis == TRUE){
MaxYPDFValue <- 0.015
MinYPDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si es FALSO, calcula los límites Y automáticamente
if(FixYPDFAxis == FALSE){
MaxYPDFValue = max(y1)
MinYPDFValue = min(y1)
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si el eje X no está fijo, calcúlalo automáticamente
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Definición de títulos y etiquetas para el gráfico
legtxt = c("Normal PDF")
mTitle = "Normal PDF"
xTitle = "Stock Price"
yTitle = "PDF"
lTitle = "Parameter"
# Recalcula los estadísticos de la Normal
NormalM = StockPrice*exp((InterestRate/100)*TimeToMaturity)
NormalSD = Volatility*TimeToMaturity
NMedian <- NormalM
NMode <- NormalM
NSkewness <- NormalSkewness()
NExcessKurtosis <- NormalExcessKurtosis()
# Creación del subtítulo con los estadísticos (Plot footers)
TNM = paste0('E(S)=', round(NormalM,2))
TNSD = paste0(',SD(S)=', round(NormalSD,4))
TNMed = paste0(',Median=', round(NMedian,2))
TNMod = paste0(',Mode=', round(NMode,2))
TNSk = paste0(',Sk=', round(NSkewness,2))
TNEK = paste0(',EKurt=', round(NExcessKurtosis,2))
# Concatena todos los textos
sTitle = paste0(TNM, TNSD, TNMed, TNMod, TNSk, TNEK)
# Genera el gráfico (plot)
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 2: CDF Normal
# ---
x <- SP
y1 <- NormalCDFV
# Fija los límites del eje Y para la CDF (usualmente 0 a 1)
if(FixYCDFAxis == TRUE){
MaxYCDFValue <- 1.0
MinYCDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
if(FixYCDFAxis == FALSE){
MaxYCDFValue = max(y1)
MinYCDFValue = min(y1)
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
# Revisa el eje X (si no está fijo)
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Normal CDF")
mTitle = "Normal CDF"
xTitle = "Stock Price"
yTitle = "CDF"
lTitle = "Parameter"
# Genera el gráfico CDF Normal
# Nota: Reutiliza el 'sTitle' (subtítulo) calculado para la PDF Normal
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 3: PDF Lognormal
# ---
x <- SP
y1 <- LognormalPDFV
# Fija los límites del eje Y para la PDF
if(FixYPDFAxis == TRUE){
MaxYPDFValue <- 0.015
MinYPDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si es FALSO, calcula automáticamente, ignorando los NAs (na.rm=TRUE)
if(FixYPDFAxis == FALSE){
MaxYPDFValue = max(y1,na.rm=TRUE)
MinYPDFValue = min(y1,na.rm=TRUE)
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Revisa el eje X
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Lognormal PDF")
mTitle = "Lognormal PDF"
xTitle = "Stock Price"
yTitle = "PDF"
lTitle = "Parameter"
# ---
# Calcula los estadísticos REALES de la distribución Lognormal
# ---
LNMean_stat <- LognormalMean(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNSD_stat <- LognormalStandardDeviation(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNMedian <- LognormalMedian(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNMode <- LognormalMode(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNSKewness <- LognormalSkewness(Volatility, TimeToMaturity)
LNExcessKurtosis <- LognormalExcessKurtosis(Volatility, TimeToMaturity)
# Creación del subtítulo con los estadísticos de la Lognormal
TLNM = paste0('E(S)=', round(LNMean_stat,2)) # Usando los estadísticos calculados
TLNSD = paste0(',SD(S)=', round(LNSD_stat,4))
TLNMed = paste0(',Median=', round(LNMedian,2))
TLNMod = paste0(',Mode=', round(LNMode,2))
TLNSk = paste0(',Sk=', round(LNSKewness,2))
TLNEK = paste0(',EKurt=', round(LNExcessKurtosis,2))
# Concatena los textos
sTitle = paste0(TLNM, TLNSD, TLNMed, TLNMod, TLNSk, TLNEK)
# Genera el gráfico PDF Lognormal
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 4: CDF Lognormal
# ---
x <- SP
y1 <- LognormalCDFV
# Fija los límites del eje Y para la CDF
if(FixYCDFAxis == TRUE){
MaxYCDFValue <- 1.0
MinYCDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
if(FixYCDFAxis == FALSE){
MaxYCDFValue = max(y1,na.rm=TRUE)
MinYCDFValue = min(y1,na.rm=TRUE)
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
# Revisa el eje X
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Lognormal CDF")
mTitle = "Lognormal CDF"
xTitle = "Stock Price"
yTitle = "CDF"
# Genera el gráfico CDF Lognormal
# Reutiliza el 'sTitle' de la PDF Lognormal (contiene los mismos estadísticos)
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# Guarda la volatilidad original
OriginalVolatility <- Volatility
Increment <- 50 # Define un incremento de 50%
# Este bucle EJECUTARÁ EL SCRIPT 'Density and Distribution Study.R' 5 VECES.
for(i in 1:5){
Volatility <- OriginalVolatility + (i-1)*Increment
source('Density and Distribution Study.R')
}
Volatility <- OriginalVolatility # Restaura la volatilidad original
# --- Gráfico 1: Estadísticos Lognormal vs. Volatilidad ---
NumberOfObservations = 41
LowerBound = 5.0  # Límite inferior de Volatilidad (5%)
UpperBound = 200  # Límite superior de Volatilidad (200%)
StepSize = (UpperBound - LowerBound)/(NumberOfObservations-1)
# Inicializa vectores
VolatilityV = c(1:NumberOfObservations)
LognormalMeanV <- c(1:NumberOfObservations)
LognormalMedianV <- c(1:NumberOfObservations)
LognormalModeV <- c(1:NumberOfObservations)
FI = 1L # KEY: 1 = Call, 2 = Put (No parece usarse)
# Bucle para rellenar los vectores
for(i in 1:NumberOfObservations){
VolatilityV[i] <- as.double(LowerBound + (i-1)*StepSize)
LognormalMeanV[i] = LognormalMean(StockPrice, InterestRate, DividendYield,
TimeToMaturity, VolatilityV[i])
LognormalMedianV[i] = LognormalMedian(StockPrice, InterestRate,
DividendYield, TimeToMaturity, VolatilityV[i])
LognormalModeV[i] = LognormalMode(StockPrice, InterestRate, DividendYield,
TimeToMaturity, VolatilityV[i])
}
# --- Configuración del Gráfico 1 ---
MaxYValue = max(LognormalMeanV, LognormalMedianV, LognormalModeV)
MinYValue = min(LognormalMeanV, LognormalMedianV, LognormalModeV)
ylim1 = c(1:2); ylim1[1] = MinYValue; ylim1[2] = MaxYValue
MaxXValue = max(VolatilityV)
MinXValue = min(VolatilityV)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
# Textos para el gráfico
legtxt = c("Mean","Median","Mode")
mTitle = "Lognormal Mean, Median, and Mode"
xTitle = "Volatility"
yTitle = "Value"
lTitle = "Parameter"
# Pies de página (subtítulos) del gráfico
TS = paste0('S=', StockPrice)
TR = paste0(', r=', InterestRate)
TD = paste0(', d=', DividendYield)
TTM = paste0(', Maturity=', TimeToMaturity)
sTitle = paste0(TS, TR, TD, TTM)
# Dibuja el gráfico
plot(VolatilityV, LognormalMeanV, type = "b", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
sTitle = paste0(TS, TR, TD, TTM)
# Dibuja el gráfico
plot(VolatilityV, LognormalMeanV, type = "b", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
lines(VolatilityV, LognormalMedianV, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 2, cex = 0.5)
lines(VolatilityV, LognormalModeV, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 3, cex = 0.5)
legend("bottomleft", legtxt, cex = 0.75, lwd = c(1,1,1), lty = c(2,2,2),
col = c("black","black","black"), pch = c(1,2,3), bty = "n", title = lTitle)
Wiener<-function(n,tra,h)
{
Wiener<-array(0,c(n,tra))
for(i in 1:tra) Wiener[,i]<-cumsum(c(0,rnorm(n-1,0,sqrt(h))))
Wiener
}
Win<-Wiener(301,50,.1)
win.graph()
matplot(Win,main="Trayectorias simuladas de un proceso Wiener Standard",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Wiener[i,])
lines(media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
Wiener2<-function(n,tra,h,t0,x0,mu,sigma)
{
W<-Wiener(n,tra,h)
Tiempo<-seq(t0,t0+(n-1)*h,h)
Wiener2<-x0+mu*(Tiempo-t0)+sigma*W
}
Wiener2<-function(n,tra,h,t0,x0,mu,sigma)
{
W<-Wiener(n,tra,h)
Tiempo<-seq(t0,t0+(n-1)*h,h)
Wiener2<-x0+mu*(Tiempo-t0)+sigma*W
}
Tiempo<-seq(10,10+(301-1)*.1,.1)
Win<-Wiener2(301,50,.1,10,5,1,1)
win.graph()
matplot(Tiempo,Win,main="Trayectorias simuladas de un proceso Wiener con tendencia",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Win[i,])
lines(Tiempo,media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
LognorHomo<-function(Ini,x0,n,tra,h,t0,m,sigma,m0,sigma0)
{
Win<-Wiener(n,tra,h)
if (Ini==0) Inicial<-rep(x0,tra) else Inicial<-rlnorm(tra,m0,sigma0)
LognorHomo<-array(0,c(n,tra))
Tiempo<-seq(t0,t0+(n-1)*h,h)
LognorHomo<-t(Inicial*t(exp((m-sigma^2/2)*(Tiempo-t0)+sigma*Win)))
LognorHomo
}
Tiempo<-seq(10,10+(301-1)*.1,.1)
Lognor1<-LognorHomo(1,0,301,50,.1,10,.1,.05,1,.25)
win.graph()
matplot(Tiempo,Lognor1,main="Trayectorias simuladas de un proceso Lognormal Homog�neo",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Lognor1[i,])
lines(Tiempo,media, main="Media del proceso Lognormal Homog�neo simulado",lty=1,lwd=3,type="l")
Richards<-function(t0,t,eta,kappa,q)((eta+kappa^t0)/(eta+kappa^t))^q
GeneraRichards<-function(Ini,x0,n,tra,h,t0,eta,kappa,q,sigma,m0,sigma0)
{
Win<-Wiener(n,tra,h)
if (Ini==0) Inicial<-rep(x0,tra) else Inicial<-rlnorm(tra,m0,sigma0)
GeneraRichards<-array(0,c(n,tra))
Tiempo<-seq(t0,t0+(n-1)*h,h)
GeneraRichards<-t(Inicial*t(Richards(t0,Tiempo,eta,kappa,q)*exp(sigma*Win-(sigma^2/2)*(Tiempo-t0))))
GeneraRichards
}
Tiempo<-seq(10,10+(501-1)*.1,.1)
Richards1<-GeneraRichards(1,0,501,50,.1,10,.05,.8,1.25,0.01,1,.1)
win.graph()
matplot(Tiempo,Richards1,main="Trayectorias simuladas de un proceso Richards",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,501)
for(i in 1:501) media[i]<-mean(Richards1[i,])
lines(Tiempo,media, main="Media del proceso Richards simulado",lty=1,lwd=3,type="l")
GeneraRayleigh<-function(x0,n,tra,h,a,b,sigma)
{
GeneraRayleigh<-array(0,c(n,tra))
GeneraRayleigh[1,]<-rep(x0,tra)
for(i in 1:tra)
{
U1<-rnorm(n-1,0,1)
U2<-rnorm(n-1,0,1)
V1<-U1*sqrt(h)
V2<-(h^(3/2)/2)*(U1+U2/sqrt(3))
V3<-rnorm(n-1,0,h^2/(2*sqrt(3)))
for(j in 1:(n-1))
{
z<-GeneraRayleigh[j,i]
z1<-h*(a/z+b*z)+sigma*V1[j]+(h^2)*(b^2*z-(a^2/z^3))
z2<-sigma*V2[j]*(b-a/z^2)+(a*sigma^2/z^3)*(V1[j]*V2[j]-V3[j])
GeneraRayleigh[j+1,i]<-z+z1+z2
}
}
GeneraRayleigh
}
Tiempo<-seq(10,10+(501-1)*.1,.1)
Rayleigh1<-GeneraRayleigh(15,501,25,.1,2,-.1,.4)
win.graph()
matplot(Tiempo,Rayleigh1,main="Trayectorias simuladas de un proceso de Rayleigh",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,501)
for(i in 1:501) media[i]<-mean(Rayleigh1[i,])
lines(Tiempo,media, main="Media del proceso de Rayleigh simulado",lty=1,lwd=3,type="l",xlab="Tiempo",ylab="Media")
Win<-Wiener(301,50,.1)
win.graph()
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Wiener[i,])
lines(media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
matplot(Win,main="Trayectorias simuladas de un proceso Wiener Standard",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Wiener[i,])
lines(media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
e
e
Tiempo<-seq(10,10+(301-1)*.1,.1)
Wiener<-function(n,tra,h)
{
Wiener<-array(0,c(n,tra))
for(i in 1:tra) Wiener[,i]<-cumsum(c(0,rnorm(n-1,0,sqrt(h))))
Wiener
}
Win<-Wiener(301,50,.1)
win.graph()
matplot(Win,main="Trayectorias simuladas de un proceso Wiener Standard",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Wiener[i,])
lines(media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
Wiener2<-function(n,tra,h,t0,x0,mu,sigma)
{
W<-Wiener(n,tra,h)
Tiempo<-seq(t0,t0+(n-1)*h,h)
Wiener2<-x0+mu*(Tiempo-t0)+sigma*W
}
Tiempo<-seq(10,10+(301-1)*.1,.1)
Win<-Wiener2(301,50,.1,10,5,1,1)
win.graph()
matplot(Tiempo,Win,main="Trayectorias simuladas de un proceso Wiener con tendencia",lty=1,lwd=1,type="l",xlab="Tiempo",ylab="Trayectorias")
media<-rep(0,301)
for(i in 1:301) media[i]<-mean(Win[i,])
lines(Tiempo,media, main="Media del proceso Wiener simulado",lty=1,lwd=3,type="l")
setwd("~/mstr/multivariante/cuestionario 7")
datos <- read.csv("datos_culturales.xlsx", header=TRUE, sep=",")
datos <- read.csv("datos_culturales.xlsx", header=TRUE)
library(readxl)
# 1. Cargar los datos
# Asegúrate de que el archivo está en tu directorio de trabajo
datos <- read_excel("datos_culturales.xlsx")
datos_numericos <- datos[, -1]
rownames(datos_numericos) <- datos[[1]]
dist_matrix <- dist(datos_numericos, method = "manhattan")
dist_ceuta_rioja <- as.matrix(dist_matrix)["Ceuta y Melilla", "Rioja (La)"]
print(paste("La distancia Manhattan entre Ceuta y Melilla y La Rioja es:", dist_ceuta_rioja))
es_maxima <- dist_ceuta_rioja == max(dist_matrix)
print(paste("¿Es la distancia más elevada de la matriz?:", es_maxima))
matriz_completa <- as.matrix(dist_matrix)
maxima_distancia <- max(matriz_completa)
cat("La distancia MÁXIMA es:", maxima_distancia, "\n")
# Para saber qué par de comunidades son:
indices_max <- which(matriz_completa == maxima_distancia, arr.ind = TRUE)
# Imprimimos los nombres (tomamos la primera fila de índices para evitar duplicados)
cat("Corresponde al par:", rownames(matriz_completa)[indices_max[1, 1]],
"y", colnames(matriz_completa)[indices_max[1, 2]], "\n\n")
# -------------------------------------------------------
# B. CALCULAR LA MÍNIMA DISTANCIA
# -------------------------------------------------------
# Primero: Convertimos la diagonal (que es 0) a NA para que no salga como mínimo
diag(matriz_completa) <- NA
# Ahora buscamos el mínimo ignorando los NA
minima_distancia <- min(matriz_completa, na.rm = TRUE)
cat("La distancia MÍNIMA es:", minima_distancia, "\n")
# Para saber qué par de comunidades son:
indices_min <- which(matriz_completa == minima_distancia, arr.ind = TRUE)
cat("Corresponde al par:", rownames(matriz_completa)[indices_min[1, 1]],
"y", colnames(matriz_completa)[indices_min[1, 2]], "\n")
# Nota: Verifica cómo están escritos los nombres en tu archivo (ej. "Rioja (La)" o "La Rioja")
distancia_ceuta_rioja <- as.matrix(matriz_distancias)["Ceuta y Melilla", "Rioja (La)"]
# 1. Cargar librería y datos
library(readxl)
# Asegúrate de que el nombre del archivo es correcto
datos <- read_excel("datos_culturales.xlsx")
# 2. Preparar la matriz de datos numéricos
# (Asumiendo que la primera columna tiene los nombres)
datos_num <- datos[, -1]
rownames(datos_num) <- datos[[1]]
# 3. Calcular la Matriz de Distancias MANHATTAN
matriz_distancias <- dist(datos_num, method = "manhattan")
# 4. Extraer el valor específico entre "Ceuta y Melilla" y "Rioja (La)"
# Nota: Verifica cómo están escritos los nombres en tu archivo (ej. "Rioja (La)" o "La Rioja")
distancia_ceuta_rioja <- as.matrix(matriz_distancias)["Ceuta y Melilla", "Rioja (La)"]
# 5. Comprobar si es la máxima de toda la matriz
es_maxima <- distancia_ceuta_rioja == max(matriz_distancias)
# --- IMPRIMIR RESULTADOS ---
cat("--- RESULTADOS DEL ANÁLISIS ---\n")
cat("Distancia Manhattan calculada:", distancia_ceuta_rioja, "\n")
cat("¿Es la distancia más alta de toda la matriz?:", es_maxima, "\n\n")
cat("CONCLUSIÓN:\n")
if(distancia_ceuta_rioja > 100) {
cat("El valor es alto (~140). La opción correcta es la 'd'.\n")
cat("Justificación: Es la distancia máxima, por lo que en el dendrograma (linkage simple o completo)\n")
cat("serán de las ÚLTIMAS comunidades en unirse por ser las más diferentes.")
} else {
cat("El valor es bajo (~61). Revisa si la pregunta pedía Euclídea o si los datos son distintos.\n")
}
library(readxl)
datos <- read_excel("datos_culturales.xlsx")
datos_num <- datos[, -1]
rownames(datos_num) <- datos[[1]]
d <- dist(datos_num, method = "euclidean")
hc_ward <- hclust(d, method = "ward.D2")
hc_average <- hclust(d, method = "average")
hc_complete <- hclust(d, method = "complete")
cor_ward <- cor(d, cophenetic(hc_ward))
cor_average <- cor(d, cophenetic(hc_average))
cor_complete <- cor(d, cophenetic(hc_complete))
cat("Coeficiente correlación cofenético Ward:", cor_ward, "\n")
cat("Coeficiente correlación cofenético Medias (Average):", cor_average, "\n")
cat("Coeficiente correlación cofenético Completo:", cor_complete, "\n")
# Definir la matriz de centros limpiando el error de sintaxis del enunciado
valores_centros <- c(
91.6, 86.5, 6.6, 23.1, 3.4, 84.3, 43.9, 26.4, 39.3, 13.2, 13.0, 19.1,
96.9, 85.8, 8.3, 36.8, 5.6, 77.3, 49.6, 19.4, 30.4, 14.7, 12.1, 7.0,
93.9, 77.5, 9.2, 33.3, 8.3, 76.5, 34.2, 30.8, 48.8, 29.9, 16.2, 11.8,
92.3, 84.3, 11.4, 37.4, 6.0, 76.6, 40.3, 32.3, 60.2, 18.6, 18.1, 14.4
)
centros <- matrix(valores_centros, ncol = 12, byrow = TRUE)
# Ejecutar K-means con los centros fijos
resultado_kmeans <- kmeans(datos_num, centers = centros)
# Identificar y mostrar el grupo que tiene exactamente 2 comunidades
clusters <- resultado_kmeans$cluster
for (i in 1:4) {
miembros <- names(clusters[clusters == i])
if (length(miembros) == 2) {
cat("Respuesta correcta encontrada en el Cluster", i, ":\n")
print(miembros)
}
}
# 2. Ejecutar K-means para k=3 y k=4 (usamos nstart alto para estabilidad)
set.seed(123) # Semilla para reproducibilidad
km3 <- kmeans(datos_num, centers = 3, nstart = 25)
km4 <- kmeans(datos_num, centers = 4, nstart = 25)
# 3. Calcular el porcentaje de varianza explicada (Betweenss / Totss)
prop3 <- (km3$betweenss / km3$totss) * 100
prop4 <- (km4$betweenss / km4$totss) * 100
# 4. Imprimir resultados
cat("Para 3 centros (k=3):", round(prop3, 1), "%\n")
cat("Para 4 centros (k=4):", round(prop4, 1), "%\n")
