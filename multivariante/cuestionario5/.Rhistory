# Genera el gráfico CDF Normal
# Nota: Reutiliza el 'sTitle' (subtítulo) calculado para la PDF Normal
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 3: PDF Lognormal
# ---
x <- SP
y1 <- LognormalPDFV
# Fija los límites del eje Y para la PDF
if(FixYPDFAxis == TRUE){
MaxYPDFValue <- 0.015
MinYPDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si es FALSO, calcula automáticamente, ignorando los NAs (na.rm=TRUE)
if(FixYPDFAxis == FALSE){
MaxYPDFValue = max(y1,na.rm=TRUE)
MinYPDFValue = min(y1,na.rm=TRUE)
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Revisa el eje X
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Lognormal PDF")
mTitle = "Lognormal PDF"
xTitle = "Stock Price"
yTitle = "PDF"
lTitle = "Parameter"
# ---
# Calcula los estadísticos REALES de la distribución Lognormal
# ---
LNMean_stat <- LognormalMean(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNSD_stat <- LognormalStandardDeviation(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
# Estudio de Densidad y Distribución.R
#
# NOTA IMPORTANTE: Este script asume que las funciones de los archivos anteriores
# (PDFNormal, CDFNormal, PDFLognormal, CDFLognormal, MediaLognormal, etc.)
# y las variables de entrada (StockPrice, InterestRate, Volatility, etc.)
# ya existen en el entorno de R.
# ---
# 1. INICIALIZACIÓN Y CÁLCULO DE DATOS
# ---
# Fuentes en 3.8 Prueba de Integración Numérica.R
# PDFs y CDFs
#
# Define la "resolución" de las gráficas (cuántos puntos calcular)
NumberOfObservations = 1001
# Inicializa los vectores que contendrán los datos de las gráficas.
SP = c(1:NumberOfObservations) # Eje X (Precios)
NormalPDFV = c(1:NumberOfObservations) # Vector para Y, PDF Normal
NormalCDFV <- c(1:NumberOfObservations) # Vector para Y, CDF Normal
LognormalPDFV = c(1:NumberOfObservations) # Vector para Y, PDF Lognormal
LognormalCDFV <- c(1:NumberOfObservations) # Vector para Y, CDF Lognormal
# ---
# Cálculo de parámetros para las distribuciones
# ---
# Parámetros para una DISTRIBUCIÓN NORMAL (para comparación).
# NOTA: Estos NO son los parámetros BSM.
NormalM = StockPrice*exp((InterestRate/100)*TimeToMaturity)
NormalSD = Volatility*TimeToMaturity
# Parámetros para la DISTRIBUCIÓN LOGNORMAL (Modelo BSM).
# Estos son los parámetros (μ y σ) de la distribución NORMAL *subyacente*.
LNMean <- log(StockPrice) + (InterestRate/100 - DividendYield/100 -
((Volatility/100)^2)/2)*TimeToMaturity
LNSD <- (Volatility/100)*sqrt(TimeToMaturity)
# ---
# Definir el rango del eje X para las gráficas
# ---
# El rango se basará en la distribución Normal de comparación
LowerBound = NormalM - 10*NormalSD
UpperBound = NormalM + 10*NormalSD
StepSize = (UpperBound - LowerBound)/(NumberOfObservations-1)
# Guarda el StockPrice original, ya que la variable se usará dentro del bucle
OriginalSP <- StockPrice
# ---
# Bucle principal para generar los puntos (x, y) de las gráficas
# ---
for(i in 1:NumberOfObservations){
# Calcula el valor del Eje X (Precio) para esta iteración
SP[i] <- as.double(LowerBound + (i-1)*StepSize)
# Sobrescribe temporalmente la variable 'StockPrice'
StockPrice <- SP[i]
# Calcula la PDF y CDF de la distribución NORMAL simple
NormalPDFV[i] <- NormalPDF(StockPrice, NormalM, NormalSD)
NormalCDFV[i] <- NormalCDF(StockPrice, NormalM, NormalSD)
# La Lognormal solo está definida para precios > 0
if(StockPrice > 0){
# Calcula la PDF y CDF Lognormal usando los parámetros BSM (subyacentes)
LognormalPDFV[i] <- LognormalPDF(StockPrice, LNMean, LNSD)
LognormalCDFV[i] <- LognormalCDF(StockPrice, LNMean, LNSD)
} else {
# Asigna NA (Not Available) si el precio es 0 o negativo
LognormalPDFV[i] <- NA
LognormalCDFV[i] <- NA
}
}
# Restaura el valor original de StockPrice
StockPrice <- OriginalSP
# ---
# 2. SECCIÓN DE GRÁFICOS
# ---
# Define los límites del eje X si la variable global 'FixXAxis' es VERDADERA
if(FixXAxis == TRUE){
MaxXValue <- 500
MinXValue <- -500
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Establece variables globales que usará 'Density and Distribution Study.R'
FixXAxis <- TRUE
FixYPDFAxis <- TRUE
FixYCDFAxis <- TRUE
mTitle = "Lognormal PDF"
# Estudio de Densidad y Distribución.R
#
# NOTA IMPORTANTE: Este script asume que las funciones de los archivos anteriores
# (PDFNormal, CDFNormal, PDFLognormal, CDFLognormal, MediaLognormal, etc.)
# y las variables de entrada (StockPrice, InterestRate, Volatility, etc.)
# ya existen en el entorno de R.
# ---
# 1. INICIALIZACIÓN Y CÁLCULO DE DATOS
# ---
# Fuentes en 3.8 Prueba de Integración Numérica.R
# PDFs y CDFs
#
# Define la "resolución" de las gráficas (cuántos puntos calcular)
NumberOfObservations = 1001
# Inicializa los vectores que contendrán los datos de las gráficas.
SP = c(1:NumberOfObservations) # Eje X (Precios)
NormalPDFV = c(1:NumberOfObservations) # Vector para Y, PDF Normal
NormalCDFV <- c(1:NumberOfObservations) # Vector para Y, CDF Normal
LognormalPDFV = c(1:NumberOfObservations) # Vector para Y, PDF Lognormal
LognormalCDFV <- c(1:NumberOfObservations) # Vector para Y, CDF Lognormal
# ---
# Cálculo de parámetros para las distribuciones
# ---
# Parámetros para una DISTRIBUCIÓN NORMAL (para comparación).
# NOTA: Estos NO son los parámetros BSM.
NormalM = StockPrice*exp((InterestRate/100)*TimeToMaturity)
NormalSD = Volatility*TimeToMaturity
# Parámetros para la DISTRIBUCIÓN LOGNORMAL (Modelo BSM).
# Estos son los parámetros (μ y σ) de la distribución NORMAL *subyacente*.
LNMean <- log(StockPrice) + (InterestRate/100 - DividendYield/100 -
((Volatility/100)^2)/2)*TimeToMaturity
LNSD <- (Volatility/100)*sqrt(TimeToMaturity)
# ---
# Definir el rango del eje X para las gráficas
# ---
# El rango se basará en la distribución Normal de comparación
LowerBound = NormalM - 10*NormalSD
UpperBound = NormalM + 10*NormalSD
StepSize = (UpperBound - LowerBound)/(NumberOfObservations-1)
# Guarda el StockPrice original, ya que la variable se usará dentro del bucle
OriginalSP <- StockPrice
# ---
# Bucle principal para generar los puntos (x, y) de las gráficas
# ---
for(i in 1:NumberOfObservations){
# Calcula el valor del Eje X (Precio) para esta iteración
SP[i] <- as.double(LowerBound + (i-1)*StepSize)
# Sobrescribe temporalmente la variable 'StockPrice'
StockPrice <- SP[i]
# Calcula la PDF y CDF de la distribución NORMAL simple
NormalPDFV[i] <- NormalPDF(StockPrice, NormalM, NormalSD)
NormalCDFV[i] <- NormalCDF(StockPrice, NormalM, NormalSD)
# La Lognormal solo está definida para precios > 0
if(StockPrice > 0){
# Calcula la PDF y CDF Lognormal usando los parámetros BSM (subyacentes)
LognormalPDFV[i] <- LognormalPDF(StockPrice, LNMean, LNSD)
LognormalCDFV[i] <- LognormalCDF(StockPrice, LNMean, LNSD)
} else {
# Asigna NA (Not Available) si el precio es 0 o negativo
LognormalPDFV[i] <- NA
LognormalCDFV[i] <- NA
}
}
# Restaura el valor original de StockPrice
StockPrice <- OriginalSP
# ---
# 2. SECCIÓN DE GRÁFICOS
# ---
# Define los límites del eje X si la variable global 'FixXAxis' es VERDADERA
if(FixXAxis == TRUE){
MaxXValue <- 500
MinXValue <- -500
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# ---
# Gráfico 1: PDF Normal
# ---
x <- SP
y1 <- NormalPDFV
# Fija los límites del eje Y para la PDF si 'FixYPDFAxis' es VERDADERO
if(FixYPDFAxis == TRUE){
MaxYPDFValue <- 0.015
MinYPDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si es FALSO, calcula los límites Y automáticamente
if(FixYPDFAxis == FALSE){
MaxYPDFValue = max(y1)
MinYPDFValue = min(y1)
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si el eje X no está fijo, calcúlalo automáticamente
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Definición de títulos y etiquetas para el gráfico
legtxt = c("Normal PDF")
mTitle = "Normal PDF"
xTitle = "Stock Price"
yTitle = "PDF"
lTitle = "Parameter"
# Recalcula los estadísticos de la Normal
NormalM = StockPrice*exp((InterestRate/100)*TimeToMaturity)
NormalSD = Volatility*TimeToMaturity
NMedian <- NormalM
NMode <- NormalM
NSkewness <- NormalSkewness()
NExcessKurtosis <- NormalExcessKurtosis()
# Creación del subtítulo con los estadísticos (Plot footers)
TNM = paste0('E(S)=', round(NormalM,2))
TNSD = paste0(',SD(S)=', round(NormalSD,4))
TNMed = paste0(',Median=', round(NMedian,2))
TNMod = paste0(',Mode=', round(NMode,2))
TNSk = paste0(',Sk=', round(NSkewness,2))
TNEK = paste0(',EKurt=', round(NExcessKurtosis,2))
# Concatena todos los textos
sTitle = paste0(TNM, TNSD, TNMed, TNMod, TNSk, TNEK)
# Genera el gráfico (plot)
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 2: CDF Normal
# ---
x <- SP
y1 <- NormalCDFV
# Fija los límites del eje Y para la CDF (usualmente 0 a 1)
if(FixYCDFAxis == TRUE){
MaxYCDFValue <- 1.0
MinYCDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
if(FixYCDFAxis == FALSE){
MaxYCDFValue = max(y1)
MinYCDFValue = min(y1)
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
# Revisa el eje X (si no está fijo)
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Normal CDF")
mTitle = "Normal CDF"
xTitle = "Stock Price"
yTitle = "CDF"
lTitle = "Parameter"
# Genera el gráfico CDF Normal
# Nota: Reutiliza el 'sTitle' (subtítulo) calculado para la PDF Normal
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 3: PDF Lognormal
# ---
x <- SP
y1 <- LognormalPDFV
# Fija los límites del eje Y para la PDF
if(FixYPDFAxis == TRUE){
MaxYPDFValue <- 0.015
MinYPDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Si es FALSO, calcula automáticamente, ignorando los NAs (na.rm=TRUE)
if(FixYPDFAxis == FALSE){
MaxYPDFValue = max(y1,na.rm=TRUE)
MinYPDFValue = min(y1,na.rm=TRUE)
ylim1 = c(1:2); ylim1[1] = MinYPDFValue; ylim1[2] = MaxYPDFValue
}
# Revisa el eje X
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Lognormal PDF")
mTitle = "Lognormal PDF"
xTitle = "Stock Price"
yTitle = "PDF"
lTitle = "Parameter"
# ---
# Calcula los estadísticos REALES de la distribución Lognormal
# ---
LNMean_stat <- LognormalMean(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNSD_stat <- LognormalStandardDeviation(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNMedian <- LognormalMedian(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNMode <- LognormalMode(StockPrice, InterestRate, DividendYield,
TimeToMaturity, Volatility)
LNSKewness <- LognormalSkewness(Volatility, TimeToMaturity)
LNExcessKurtosis <- LognormalExcessKurtosis(Volatility, TimeToMaturity)
# Creación del subtítulo con los estadísticos de la Lognormal
TLNM = paste0('E(S)=', round(LNMean_stat,2)) # Usando los estadísticos calculados
TLNSD = paste0(',SD(S)=', round(LNSD_stat,4))
TLNMed = paste0(',Median=', round(LNMedian,2))
TLNMod = paste0(',Mode=', round(LNMode,2))
TLNSk = paste0(',Sk=', round(LNSKewness,2))
TLNEK = paste0(',EKurt=', round(LNExcessKurtosis,2))
# Concatena los textos
sTitle = paste0(TLNM, TLNSD, TLNMed, TLNMod, TLNSk, TLNEK)
# Genera el gráfico PDF Lognormal
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# ---
# Gráfico 4: CDF Lognormal
# ---
x <- SP
y1 <- LognormalCDFV
# Fija los límites del eje Y para la CDF
if(FixYCDFAxis == TRUE){
MaxYCDFValue <- 1.0
MinYCDFValue <- 0
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
if(FixYCDFAxis == FALSE){
MaxYCDFValue = max(y1,na.rm=TRUE)
MinYCDFValue = min(y1,na.rm=TRUE)
ylim1 = c(1:2); ylim1[1] = MinYCDFValue; ylim1[2] = MaxYCDFValue
}
# Revisa el eje X
if(FixXAxis == FALSE){
MaxXValue = max(x)
MinXValue = min(x)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
}
# Títulos
legtxt = c("Lognormal CDF")
mTitle = "Lognormal CDF"
xTitle = "Stock Price"
yTitle = "CDF"
# Genera el gráfico CDF Lognormal
# Reutiliza el 'sTitle' de la PDF Lognormal (contiene los mismos estadísticos)
plot(x, y1, type = "l", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# Guarda la volatilidad original
OriginalVolatility <- Volatility
Increment <- 50 # Define un incremento de 50%
# Este bucle EJECUTARÁ EL SCRIPT 'Density and Distribution Study.R' 5 VECES.
for(i in 1:5){
Volatility <- OriginalVolatility + (i-1)*Increment
source('Density and Distribution Study.R')
}
Volatility <- OriginalVolatility # Restaura la volatilidad original
# --- Gráfico 1: Estadísticos Lognormal vs. Volatilidad ---
NumberOfObservations = 41
LowerBound = 5.0  # Límite inferior de Volatilidad (5%)
UpperBound = 200  # Límite superior de Volatilidad (200%)
StepSize = (UpperBound - LowerBound)/(NumberOfObservations-1)
# Inicializa vectores
VolatilityV = c(1:NumberOfObservations)
LognormalMeanV <- c(1:NumberOfObservations)
LognormalMedianV <- c(1:NumberOfObservations)
LognormalModeV <- c(1:NumberOfObservations)
FI = 1L # KEY: 1 = Call, 2 = Put (No parece usarse)
# Bucle para rellenar los vectores
for(i in 1:NumberOfObservations){
VolatilityV[i] <- as.double(LowerBound + (i-1)*StepSize)
LognormalMeanV[i] = LognormalMean(StockPrice, InterestRate, DividendYield,
TimeToMaturity, VolatilityV[i])
LognormalMedianV[i] = LognormalMedian(StockPrice, InterestRate,
DividendYield, TimeToMaturity, VolatilityV[i])
LognormalModeV[i] = LognormalMode(StockPrice, InterestRate, DividendYield,
TimeToMaturity, VolatilityV[i])
}
# --- Configuración del Gráfico 1 ---
MaxYValue = max(LognormalMeanV, LognormalMedianV, LognormalModeV)
MinYValue = min(LognormalMeanV, LognormalMedianV, LognormalModeV)
ylim1 = c(1:2); ylim1[1] = MinYValue; ylim1[2] = MaxYValue
MaxXValue = max(VolatilityV)
MinXValue = min(VolatilityV)
xlim1 = c(1:2); xlim1[1] = MinXValue; xlim1[2] = MaxXValue
# Textos para el gráfico
legtxt = c("Mean","Median","Mode")
mTitle = "Lognormal Mean, Median, and Mode"
xTitle = "Volatility"
yTitle = "Value"
lTitle = "Parameter"
# Pies de página (subtítulos) del gráfico
TS = paste0('S=', StockPrice)
TR = paste0(', r=', InterestRate)
TD = paste0(', d=', DividendYield)
TTM = paste0(', Maturity=', TimeToMaturity)
sTitle = paste0(TS, TR, TD, TTM)
# Dibuja el gráfico
plot(VolatilityV, LognormalMeanV, type = "b", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
sTitle = paste0(TS, TR, TD, TTM)
# Dibuja el gráfico
plot(VolatilityV, LognormalMeanV, type = "b", main = mTitle,
sub = sTitle, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
lines(VolatilityV, LognormalMedianV, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 2, cex = 0.5)
lines(VolatilityV, LognormalModeV, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 3, cex = 0.5)
legend("bottomleft", legtxt, cex = 0.75, lwd = c(1,1,1), lty = c(2,2,2),
col = c("black","black","black"), pch = c(1,2,3), bty = "n", title = lTitle)
setwd("C:/Users/juanr/Desktop/mstr/multivariante/cuestionario5")
datos <- read.table("Genero.txt", header = TRUE)
datos_mca <- subset(datos, select = -Continent)
s <- ncol(datos_mca)
p <- sum(sapply(datos_mca, function(x) length(unique(x))))
p <- sum(sapply(datos_mca, function(x) length(unique(x))))
total_dimensiones <- p - s
inercia_total <- (p / s) - 1
print(paste("Número de variables (s):", s))
print(paste("Número total de categorías (p):", p))
print(paste("Número total de dimensiones (p - s):", total_dimensiones))
print(paste("Inercia total ((p / s) - 1):", inercia_total))
library(ade4)
datos_mca_factors <- data.frame(lapply(datos_mca, as.factor))
acm_resultado <- dudi.acm(datos_mca_factors, scannf = FALSE, nf = 9)
inercias_ejes <- acm_resultado$eig
inercia_total <- sum(inercias_ejes)
inercia_total <- (p / s) - 1
inercia_total2 <- sum(inercias_ejes)
inercia_total <- sum(inercias_ejes)
total_dimensiones2 <- length(inercias_ejes)
inercia_media <- inercia_total / total_dimensiones
ejes_sobre_media <- sum(inercias_ejes > inercia_media)
inercia_dos_primeros_ejes <- sum(inercias_ejes[1:2])
porcentaje_dos_primeros_ejes <- (inercia_dos_primeros_ejes / inercia_total) * 100
# 1. Cargar la librería 'factoextra'
# (Mencionada en los apuntes, p.ej., )
# install.packages("factoextra") # Descomentar si no está instalada
library(factoextra)
contrib_plot_1_3 <- fviz_contrib(acm_resultado, choice = "var", axes = c(1, 3))
contrib_data <- contrib_plot_1_3$data
print(contrib_data)
max_contrib <- contrib_data[which.max(contrib_data$contrib), ]
print(max_contrib)
min_contrib <- contrib_data[which.min(contrib_data$contrib), ]
print(min_contrib)
# 5. Ordenar los datos de contribución
# Orden ascendente (de menor a mayor contribución)
contrib_orden_asc <- contrib_data[order(contrib_data$contrib), ]
# Orden descendente (de mayor a menor contribución)
contrib_orden_desc <- contrib_data[order(contrib_data$contrib, decreasing = TRUE), ]
# 6. Extraer y mostrar las dos categorías con MÁXIMA contribución
# Usamos head() sobre el data.frame ordenado de forma descendente
max_2_contrib <- head(contrib_orden_desc, 2)
print("--- Dos categorías con MÁXIMA contribución al plano 1-3 ---")
print(max_2_contrib)
# 7. Extraer y mostrar las dos categorías con MÍNIMA contribución
# Usamos head() sobre el data.frame ordenado de forma ascendente
min_2_contrib <- head(contrib_orden_asc, 2)
print("--- Dos categorías con MÍNIMA contribución al plano 1-3 ---")
print(min_2_contrib)
library(factoextra)
acm <- acm_resultado
print(
fviz_mca_var(acm, axes=c(1,2), choice="var.cat", repel=T,
gradient.cols=c("yellow","orange","red","blue","black"),
col.var="contrib")
)
library(ade4)
library(ade4)
datos_matriz <- matrix(c(40, 15,  9,  5,
30, 30, 15,  7,
10, 15, 10,  5,
5, 10, 15, 10),
nrow = 4, byrow = TRUE)
datos_acs <- as.data.frame(datos_matriz)
colnames(datos_acs) <- c("JIF1", "JIF2", "JIF3", "JIF4")
rownames(datos_acs) <- c("HDI1", "HDI2", "HDI3", "HDI4")
acs_simple <- dudi.coa(datos_acs, scannf = FALSE)
inercias_ejes <- acs_simple$eig
inercia_total <- sum(inercias_ejes)
inercia_eje_1 <- inercias_ejes[1]
porcentaje_eje_1 <- (inercia_eje_1 / inercia_total) * 100
print(paste("La inercia total es:", round(inercia_total, 5)))
print(paste("La inercia del Eje 1 es:", round(inercia_eje_1, 5)))
print("---")
print(paste("Respuesta: El porcentaje de varianza explicada por el primer eje es:",
round(porcentaje_eje_1, 2), "%"))
print(paste("La inercia total es:", round(inercia_total, 5)))
print(paste("La inercia del Eje 1 es:", round(inercia_eje_1, 5)))
print(paste("Respuesta: El porcentaje de varianza explicada por el primer eje es:",
round(porcentaje_eje_1, 2), "%"))
print(
fviz_ca_biplot(acs_simple, map = "colprincipal", arrow = c(TRUE, TRUE))
)
