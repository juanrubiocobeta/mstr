library(tidyr)
# 1. Definicion de Parametros del Modelo (Ejercicio 2)
# x(k+1) = -1*x(k) + 0*w(k)
# z(k)   = 1*x(k) + v(k)
Phi <- -1
H   <- 1
Q   <- 0    # No hay ruido de proceso
R   <- 0.5  # Varianza de v(k)
P0  <- 1    # Varianza de x(0)
x0_media <- 0
# 2. Parametros de Simulacion y Suavizado
N_iter    <- 20 # 20 iteraciones (k=0 a 20)
N_steps   <- N_iter + 1
N_horizons <- c(1, 2, 4) # Horizontes N para suavizado
N_max     <- max(N_horizons)
time <- 0:N_iter
set.seed(123) # Para reproducibilidad
# 3. Simulacion del Sistema (x(k+1) = -x(k))
x_true <- numeric(N_steps)
z_obs  <- numeric(N_steps)
v <- rnorm(N_steps, 0, sqrt(R)) # Ruido de observacion
x_true[1] <- rnorm(1, x0_media, sqrt(P0))
z_obs[1]  <- H * x_true[1] + v[1]
for (i in 2:N_steps) {
x_true[i] <- Phi * x_true[i-1]
z_obs[i]  <- H * x_true[i] + v[i]
}
# 4. FASE 1: Algoritmo de Filtrado de Kalman
# Almacenamos todos los resultados necesarios
x_pred <- numeric(N_steps) # x_hat(k/k-1)
P_pred <- numeric(N_steps) # P(k/k-1)
x_fil  <- numeric(N_steps) # x_hat(k/k)
P_fil  <- numeric(N_steps) # P(k/k)
K_gain <- numeric(N_steps) # K(k)
innov  <- numeric(N_steps) # z_tilde(k/k-1)
Pi_cov <- numeric(N_steps) # Cov(innov)
# Inicializacion k=0
x_pred[1] <- x0_media
P_pred[1] <- P0
Pi_cov[1] <- H * P_pred[1] * H + R
K_gain[1] <- P_pred[1] * H / Pi_cov[1]
innov[1]  <- z_obs[1] - H * x_pred[1]
x_fil[1]  <- x_pred[1] + K_gain[1] * innov[1]
P_fil[1]  <- (1 - K_gain[1] * H) * P_pred[1]
# Bucle del Filtro k=1 hasta k=N_iter
for (i in 2:N_steps) {
x_pred[i] <- Phi * x_fil[i-1]
P_pred[i] <- P_fil[i-1] + Q
Pi_cov[i] <- H * P_pred[i] * H + R
K_gain[i] <- P_pred[i] * H / Pi_cov[i]
innov[i]  <- z_obs[i] - H * x_pred[i]
x_fil[i]  <- x_pred[i] + K_gain[i] * innov[i]
P_fil[i]  <- (1 - K_gain[i] * H) * P_pred[i]
}
# 5. FASE 2: Algoritmo de Suavizamiento Punto Fijo
x_smooth <- matrix(NA, nrow = N_steps, ncol = length(N_horizons))
P_smooth <- matrix(NA, nrow = N_steps, ncol = length(N_horizons))
colnames(x_smooth) <- paste0("N=", N_horizons)
colnames(P_smooth) <- paste0("N=", N_horizons)
# Bucle EXTERNO: Itera sobre cada punto k que queremos suavizar
for (i in 1:N_steps) {
# Inicializamos el suavizador en j=k
x_smooth_current <- x_fil[i]
P_smooth_current <- P_fil[i]
L_current <- P_fil[i]
# Bucle INTERNO: Itera hacia el futuro (j = k+1, ..., k+N_max)
for (j_offset in 1:N_max) {
j_idx <- i + j_offset # Indice de j (j=k+j_offset)
if (j_idx > N_steps) { break }
K_smooth_j <- L_current * Phi * H / Pi_cov[j_idx]
x_smooth_current <- x_smooth_current + K_smooth_j * innov[j_idx]
P_smooth_current <- P_smooth_current - K_smooth_j * Pi_cov[j_idx] * K_smooth_j
L_current <- L_current * Phi * (1 - K_gain[j_idx] * H)
if (j_offset %in% N_horizons) {
col_idx <- which(N_horizons == j_offset)
x_smooth[i, col_idx] <- x_smooth_current
P_smooth[i, col_idx] <- P_smooth_current
}
}
}
# GRAFICA 1: Trayectorias
data_g1 <- data.frame(
Tiempo = time,
Estado_Real = x_true,
Observacion = z_obs,
Filtrado = x_fil,
Suavizado_N2 = x_smooth[, "N=2"]
)
data_g1$Suavizado_N2[is.na(data_g1$Suavizado_N2)] <- data_g1$Filtrado[is.na(data_g1$Suavizado_N2)]
data_g1_long <- tidyr::pivot_longer(
data_g1,
cols = -Tiempo,
names_to = "Serie",
values_to = "Valor"
)
g1 <- ggplot(data_g1_long, aes(x = Tiempo, y = Valor, color = Serie)) +
geom_line(aes(linetype = Serie), size = 0.8) +
geom_point(data = subset(data_g1_long, Serie == "Observacion"), size = 1.5, shape = 1) +
scale_linetype_manual(values = c(
"Estado_Real" = "solid",
"Observacion" = "blank",
"Filtrado" = "dashed",
"Suavizado_N2" = "solid"
)) +
scale_color_manual(values = c(
"Estado_Real" = "black",
"Observacion" = "grey50",
"Filtrado" = "blue",
"Suavizado_N2" = "red"
)) +
labs(
title = "Comparativa de Estimaciones (N=2)",
x = "Tiempo (k)",
y = "Valor",
color = "Series",
linetype = "Series"
) +
theme_minimal() +
theme(legend.position = "bottom")
# GRAFICA 2: Varianzas
data_g2 <- data.frame(
Tiempo = time,
Filtrado = P_fil,
Suavizado_N1 = P_smooth[, "N=1"],
Suavizado_N2 = P_smooth[, "N=2"],
Suavizado_N4 = P_smooth[, "N=4"]
)
# Rellenamos los NA al final con el valor del filtro
data_g2[is.na(data_g2)] <- data_g2$Filtrado[is.na(data_g2)]
data_g2_long <- tidyr::pivot_longer(
data_g2,
cols = -Tiempo,
names_to = "Serie",
values_to = "Varianza"
)
# Reordenamos factores para que la leyenda salga ordenada
data_g2_long$Serie <- factor(data_g2_long$Serie, levels = c("Filtrado", "Suavizado_N1", "Suavizado_N2", "Suavizado_N4"))
g2 <- ggplot(data_g2_long, aes(x = Tiempo, y = Varianza, color = Serie)) +
geom_line(size = 0.8) +
labs(
title = "Comparativa de Varianzas del Error",
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Estimador"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g1)
print(g2)
# --- 0. Cargar Librerias ---
library(ggplot2)
library(tidyr)
# --- 1. Definicion del Modelo ---
# x(k+1) = -1*x(k) + 0*w(k)
# z(k)   = 1*x(k) + v(k)
Phi <- -1
H   <- 1
Q   <- 0    # No hay ruido de proceso
N_iter <- 20 # 20 iteraciones
N_steps <- N_iter + 1
time <- 0:N_iter
# --- 2. Función para calcular la Varianza del Filtro ---
# Esta funcion calcula la evolucion de P(k/k) dados P0 y R
calcular_varianza_filtro <- function(P0_val, R_val, Phi, H, Q, N_steps) {
P_pred <- numeric(N_steps)
P_fil  <- numeric(N_steps)
# Inicializacion k=0
P_pred[1] <- P0_val
# Primera actualizacion (k=0)
Pi_cov_k0 <- H * P_pred[1] * H + R_val
K_gain_k0 <- P_pred[1] * H / Pi_cov_k0
P_fil[1]  <- (1 - K_gain_k0 * H) * P_pred[1]
# Bucle del Filtro k=1 hasta k=N_iter
for (i in 2:N_steps) {
# Prediccion de Varianza
# P(k/k-1) = Phi*P(k-1/k-1)*Phi' + Q = (-1)^2*P(k-1/k-1) + 0
P_pred[i] <- P_fil[i-1] + Q
# Actualizacion de Varianza
Pi_cov_i <- H * P_pred[i] * H + R_val
K_gain_i <- P_pred[i] * H / Pi_cov_i
P_fil[i]  <- (1 - K_gain_i * H) * P_pred[i]
}
return(P_fil)
}
# --- 3. Definicion de Escenarios ---
# Escenario 1: Base (el de apartado c)
P0_base <- 1.0
R_base <- 0.5
# Escenario 2: P0 Alto (mas incertidumbre inicial)
P0_alt <- 10.0
R_alt_P0 <- 0.5
# Escenario 3: R Alto (observaciones mas ruidosas)
P0_alt_R <- 1.0
R_alt <- 2.0
# Escenario 4: R Bajo (observaciones mas precisas)
P0_baj_R <- 1.0
R_baj <- 0.1
# --- 4. Calculo de las Varianzas para cada Escenario ---
P_fil_base <- calcular_varianza_filtro(P0_base, R_base, Phi, H, Q, N_steps)
P_fil_P0_alt <- calcular_varianza_filtro(P0_alt, R_alt_P0, Phi, H, Q, N_steps)
P_fil_R_alt <- calcular_varianza_filtro(P0_alt_R, R_alt, Phi, H, Q, N_steps)
P_fil_R_baj <- calcular_varianza_filtro(P0_baj_R, R_baj, Phi, H, Q, N_steps)
# --- 5. Preparacion de Datos y Graficacion ---
data_g3 <- data.frame(
Tiempo = time,
Varianza_Base = P_fil_base,
Varianza_P0_Alto = P_fil_P0_alt,
Varianza_R_Alto = P_fil_R_alt,
Varianza_R_Bajo = P_fil_R_baj
)
data_g3_long <- tidyr::pivot_longer(
data_g3,
cols = -Tiempo,
names_to = "Escenario",
values_to = "Varianza"
)
# Renombramos para la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("P0=10.0, R=0.5 (P0 Alto)",
"P0=1.0, R=2.0 (R Alto)",
"P0=1.0, R=0.5 (Base)",
"P0=1.0, R=0.1 (R Bajo)"))
# Creamos la Grafica
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
title = "Efecto de P0 y R en la Varianza del Error del Filtro",
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Escenario (P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
# Imprimimos la grafica
print(g3)
# --- 0. Cargar Librerias ---
library(ggplot2)
library(tidyr)
# --- 1. Definicion de Parametros del Modelo ---
Phi <- -1
H <- 1
Q <- 0
N_iter <- 20
N_steps <- N_iter + 1
time <- 0:N_iter
# --- 2. Funcion para calcular la Varianza del Filtro ---
calcular_varianza_filtro <- function(P0_val, R_val, Phi, H, Q, N_steps) {
P_pred <- numeric(N_steps)
P_fil  <- numeric(N_steps)
# Inicializacion k=0
P_pred[1] <- P0_val
Pi_cov_k0 <- H * P_pred[1] * H + R_val
K_gain_k0 <- P_pred[1] * H / Pi_cov_k0
P_fil[1]  <- (1 - K_gain_k0 * H) * P_pred[1]
# Bucle del Filtro k=1 hasta k=N_iter
for (i in 2:N_steps) {
P_pred[i] <- P_fil[i-1] + Q
Pi_cov_i <- H * P_pred[i] * H + R_val
K_gain_i <- P_pred[i] * H / Pi_cov_i
P_fil[i]  <- (1 - K_gain_i * H) * P_pred[i]
}
return(P_fil)
}
# --- 3. Definicion y calculo de Escenarios ---
P0_base <- 1.0; R_base <- 0.5
P0_alt <- 10.0; R_alt_P0 <- 0.5
P0_alt_R <- 1.0; R_alt <- 2.0
P0_baj_R <- 1.0; R_baj <- 0.1
P_fil_base <- calcular_varianza_filtro(P0_base, R_base, Phi, H, Q, N_steps)
P_fil_P0_alt <- calcular_varianza_filtro(P0_alt, R_alt_P0, Phi, H, Q, N_steps)
P_fil_R_alt <- calcular_varianza_filtro(P0_alt_R, R_alt, Phi, H, Q, N_steps)
P_fil_R_baj <- calcular_varianza_filtro(P0_baj_R, R_baj, Phi, H, Q, N_steps)
# --- 4. Preparacion de Datos para Grafica ---
data_g3 <- data.frame(
Tiempo = time,
Varianza_Base = P_fil_base,
Varianza_P0_Alto = P_fil_P0_alt,
Varianza_R_Alto = P_fil_R_alt,
Varianza_R_Bajo = P_fil_R_baj
)
data_g3_long <- tidyr::pivot_longer(
data_g3,
cols = -Tiempo,
names_to = "Escenario",
values_to = "Varianza"
)
# Definir etiquetas y orden de la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("P0=10.0, R=0.5 (P0 Alto)",
"P0=1.0, R=2.0 (R Alto)",
"P0=1.0, R=0.5 (Base)",
"P0=1.0, R=0.1 (R Bajo)"))
# --- 5. Graficacion ---
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
title = "Efecto de P0 y R en la Varianza del Error del Filtro",
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Escenario (P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
print(g3)
# 5. Representamos
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Escenario (P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
# Definir etiquetas y orden de la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("(10.0, 0.5)",
"(1.0, 2.0)",
"(1.0, 0.5) [Base]",
"(1.0, 0.1)"))
# 5. Representación
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Escenario (P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
# 0. Cargar Librerias
library(ggplot2)
library(tidyr)
# 1. Definicion de Parametros del Modelo
Phi <- -1
H <- 1
Q <- 0
N_iter <- 20
N_steps <- N_iter + 1
time <- 0:N_iter
# 2. Funcion para calcular la Varianza del Filtro
calcular_varianza_filtro <- function(P0_val, R_val, Phi, H, Q, N_steps) {
P_pred <- numeric(N_steps)
P_fil  <- numeric(N_steps)
# Inicializacion k=0
P_pred[1] <- P0_val
Pi_cov_k0 <- H * P_pred[1] * H + R_val
K_gain_k0 <- P_pred[1] * H / Pi_cov_k0
P_fil[1]  <- (1 - K_gain_k0 * H) * P_pred[1]
# Bucle del Filtro k=1 hasta k=N_iter
for (i in 2:N_steps) {
P_pred[i] <- P_fil[i-1] + Q
Pi_cov_i <- H * P_pred[i] * H + R_val
K_gain_i <- P_pred[i] * H / Pi_cov_i
P_fil[i]  <- (1 - K_gain_i * H) * P_pred[i]
}
return(P_fil)
}
# --- 3. Definicion y calculo de Escenarios ---
P0_base <- 1.0; R_base <- 0.5
P0_alt <- 10.0; R_alt_P0 <- 0.5
P0_alt_R <- 1.0; R_alt <- 2.0
P0_baj_R <- 1.0; R_baj <- 0.1
P_fil_base <- calcular_varianza_filtro(P0_base, R_base, Phi, H, Q, N_steps)
P_fil_P0_alt <- calcular_varianza_filtro(P0_alt, R_alt_P0, Phi, H, Q, N_steps)
P_fil_R_alt <- calcular_varianza_filtro(P0_alt_R, R_alt, Phi, H, Q, N_steps)
P_fil_R_baj <- calcular_varianza_filtro(P0_baj_R, R_baj, Phi, H, Q, N_steps)
# 4. Preparacion de Datos para Grafica
data_g3 <- data.frame(
Tiempo = time,
Varianza_Base = P_fil_base,
Varianza_P0_Alto = P_fil_P0_alt,
Varianza_R_Alto = P_fil_R_alt,
Varianza_R_Bajo = P_fil_R_baj
)
data_g3_long <- tidyr::pivot_longer(
data_g3,
cols = -Tiempo,
names_to = "Escenario",
values_to = "Varianza"
)
# Definir etiquetas y orden de la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("(10.0, 0.5)",
"(1.0, 2.0)",
"(1.0, 0.5) [Base]",
"(1.0, 0.1)"))
# 5. Representación
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "Escenario (P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
# 5. Representación
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "(P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
# Definir etiquetas y orden de la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("(10.0, 0.5)",
"(1.0, 2.0)",
"(1.0, 0.5)",
"(1.0, 0.1)"))
# 5. Representación
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "(P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
# 0. Cargar Librerias
library(ggplot2)
library(tidyr)
# 1. Definicion de Parametros del Modelo
Phi <- -1
H <- 1
Q <- 0
N_iter <- 20
N_steps <- N_iter + 1
time <- 0:N_iter
# 2. Funcion para calcular la Varianza del Filtro
calcular_varianza_filtro <- function(P0_val, R_val, Phi, H, Q, N_steps) {
P_pred <- numeric(N_steps)
P_fil  <- numeric(N_steps)
# Inicializacion k=0
P_pred[1] <- P0_val
Pi_cov_k0 <- H * P_pred[1] * H + R_val
K_gain_k0 <- P_pred[1] * H / Pi_cov_k0
P_fil[1]  <- (1 - K_gain_k0 * H) * P_pred[1]
# Bucle del Filtro k=1 hasta k=N_iter
for (i in 2:N_steps) {
P_pred[i] <- P_fil[i-1] + Q
Pi_cov_i <- H * P_pred[i] * H + R_val
K_gain_i <- P_pred[i] * H / Pi_cov_i
P_fil[i]  <- (1 - K_gain_i * H) * P_pred[i]
}
return(P_fil)
}
# --- 3. Definicion y calculo de Escenarios ---
P0_base <- 1.0; R_base <- 0.5
P0_alt <- 10.0; R_alt_P0 <- 0.5
P0_alt_R <- 1.0; R_alt <- 2.0
P0_baj_R <- 1.0; R_baj <- 0.1
P_fil_base <- calcular_varianza_filtro(P0_base, R_base, Phi, H, Q, N_steps)
P_fil_P0_alt <- calcular_varianza_filtro(P0_alt, R_alt_P0, Phi, H, Q, N_steps)
P_fil_R_alt <- calcular_varianza_filtro(P0_alt_R, R_alt, Phi, H, Q, N_steps)
P_fil_R_baj <- calcular_varianza_filtro(P0_baj_R, R_baj, Phi, H, Q, N_steps)
# 4. Preparacion de Datos para Grafica
data_g3 <- data.frame(
Tiempo = time,
Varianza_Base = P_fil_base,
Varianza_P0_Alto = P_fil_P0_alt,
Varianza_R_Alto = P_fil_R_alt,
Varianza_R_Bajo = P_fil_R_baj
)
data_g3_long <- tidyr::pivot_longer(
data_g3,
cols = -Tiempo,
names_to = "Escenario",
values_to = "Varianza"
)
# Definir etiquetas y orden de la leyenda
data_g3_long$Escenario <- factor(data_g3_long$Escenario,
levels = c("Varianza_P0_Alto", "Varianza_R_Alto", "Varianza_Base", "Varianza_R_Bajo"),
labels = c("(10.0, 0.5)",
"(1.0, 2.0)",
"(1.0, 0.5)",
"(1.0, 0.1)"))
# 5. Representación
g3 <- ggplot(data_g3_long, aes(x = Tiempo, y = Varianza, color = Escenario)) +
geom_line(size = 0.8) +
labs(
x = "Tiempo (k)",
y = "Varianza del Error (P)",
color = "(P0, R)"
) +
coord_cartesian(ylim = c(0, NA)) +
theme_minimal() +
theme(legend.position = "bottom")
print(g3)
